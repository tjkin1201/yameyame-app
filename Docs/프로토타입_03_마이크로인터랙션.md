# 프로토타입 03: 마이크로 인터랙션 및 감정 피드백 설계

## 🎯 마이크로 인터랙션 철학

**"모든 터치에는 감정이 있다"**

사용자의 모든 액션에 대해 즉각적이고 적절한 피드백을 제공하여, 앱 사용이 자연스럽고 만족스러운 경험이 되도록 설계합니다.

## 🧠 감정-액션 매핑

### 감정 상태별 인터랙션 설계
```javascript
const emotionBasedInteractions = {
  // 설렘/기대감 (게임 전)
  anticipation: {
    colors: ["#FF6B35", "#FF8A65"], // 따뜻한 주황
    animations: "부드럽고 경쾌한 움직임",
    timing: "빠른 반응 (100ms 이내)",
    feedback: "긍정적 사운드 + 부드러운 햅틱",
    
    examples: {
      participation: "참가 버튼 누르면 즉시 체크마크 + 환영 애니메이션",
      gameInfo: "게임 카드 터치하면 세부 정보가 부드럽게 확장"
    }
  },
  
  // 집중/몰입 (게임 중)
  focus: {
    colors: ["#2196F3", "#1976D2"], // 차분한 파랑
    animations: "최소한의 움직임, 즉시 반응",
    timing: "즉시 반응 (50ms 이내)",
    feedback: "강한 햅틱 + 명확한 시각적 변화",
    
    examples: {
      scoreInput: "점수 버튼 누르면 강한 햅틱 + 숫자 강조",
      gameUpdate: "상태 변화 시 펄스 애니메이션"
    }
  },
  
  // 만족감/성취감 (게임 후)
  satisfaction: {
    colors: ["#4CAF50", "#66BB6A"], // 성취의 초록
    animations: "축하하는 느낌의 풍성한 애니메이션",
    timing: "여유로운 타이밍 (300ms)",
    feedback: "성취감 사운드 + 길고 만족스러운 햅틱",
    
    examples: {
      gameComplete: "게임 완료 시 폭죽 애니메이션 + 성취 사운드",
      recordBreak: "개인 기록 갱신 시 특별한 셀레브레이션"
    }
  }
};
```

## 🎬 핵심 마이크로 인터랙션 상세 설계

### 1. 참가 신청 인터랙션
```javascript
const participationInteraction = {
  // 사용자 여정
  userJourney: {
    intention: "게임에 참가하고 싶다",
    emotion: "설렘 + 약간의 불안",
    expectation: "쉽고 확실하게 참가되었으면"
  },
  
  // 인터랙션 시퀀스 (총 2초)
  sequence: [
    {
      time: "0ms",
      trigger: "참가하기 버튼 터치 시작",
      action: "버튼 크기 95%로 축소 (pressed state)",
      feedback: "none"
    },
    {
      time: "50ms", 
      trigger: "터치 유지 중",
      action: "버튼 색상 진하게 변화",
      feedback: "가벼운 햅틱 (light impact)"
    },
    {
      time: "100ms",
      trigger: "터치 릴리즈",
      action: "버튼 원래 크기로 복구 + 체크마크 아이콘 등장",
      feedback: "중간 햅틱 (medium impact)"
    },
    {
      time: "300ms",
      trigger: "체크마크 완성",
      action: "버튼 전체가 녹색으로 변화 + '참가 완료' 텍스트",
      feedback: "성공 사운드 (선택적)"
    },
    {
      time: "800ms",
      trigger: "상태 업데이트",
      action: "참가자 수 카운터 애니메이션 (+1)",
      feedback: "none"
    },
    {
      time: "1200ms",
      trigger: "추가 정보 표시",
      action: "준비물 안내 카드가 아래에서 슬라이드 업",
      feedback: "none"
    },
    {
      time: "2000ms",
      trigger: "완료",
      action: "모든 애니메이션 완료, 안정 상태",
      feedback: "none"
    }
  ],
  
  // React Native 구현
  implementation: `
  const ParticipationButton = () => {
    const [isPressed, setIsPressed] = useState(false);
    const [isParticipated, setIsParticipated] = useState(false);
    const scaleAnim = useRef(new Animated.Value(1)).current;
    const checkAnim = useRef(new Animated.Value(0)).current;
    
    const handlePress = async () => {
      // 즉시 햅틱 피드백
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      
      // 버튼 애니메이션
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 0.95,
          duration: 50,
          useNativeDriver: true
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true
        })
      ]).start();
      
      // API 호출 및 상태 업데이트
      try {
        await participateInGame();
        
        // 성공 피드백
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
        setIsParticipated(true);
        
        // 체크마크 애니메이션
        Animated.timing(checkAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true
        }).start();
        
        // 선택적 사운드
        if (soundEnabled) {
          playSuccessSound();
        }
        
      } catch (error) {
        // 에러 피드백
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
        showErrorMessage(error);
      }
    };
    
    return (
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <TouchableOpacity 
          onPress={handlePress}
          style={[styles.button, isParticipated && styles.successButton]}
        >
          {isParticipated ? (
            <Animated.View style={{ opacity: checkAnim }}>
              <CheckIcon size={24} color="white" />
              <Text>참가 완료!</Text>
            </Animated.View>
          ) : (
            <Text>참가하기</Text>
          )}
        </TouchableOpacity>
      </Animated.View>
    );
  };
  `
};
```

### 2. 점수 입력 인터랙션
```javascript
const scoreInputInteraction = {
  // 컨텍스트
  context: {
    location: "체육관 코트 옆",
    userState: "땀 흘리며 급함",
    pressure: "다른 사람들이 기다림",
    device: "한 손 또는 급하게 두 손"
  },
  
  // 설계 원칙
  principles: {
    speed: "1초 내 완료 가능",
    clarity: "실수 방지 최우선",
    confidence: "입력했다는 확신 제공",
    recovery: "실수 시 쉽게 수정"
  },
  
  // 인터랙션 디자인
  design: {
    layout: "화면 분할 (팀A 상단, 팀B 하단)",
    buttonSize: "화면의 40% 크기",
    touchArea: "실제 버튼보다 20% 더 큰 터치 영역",
    feedback: "즉시 + 강력한 피드백"
  },
  
  // 시퀀스 (총 1.5초)
  sequence: [
    {
      time: "0ms",
      trigger: "팀 승리 버튼 터치",
      action: "즉시 버튼 색상 변화 + 크기 확대",
      feedback: "강한 햅틱 (heavy impact)"
    },
    {
      time: "100ms",
      trigger: "터치 유지 중",
      action: "선택된 팀 강조 + 점수 숫자 준비",
      feedback: "none"
    },
    {
      time: "200ms",
      trigger: "터치 릴리즈",
      action: "점수 +1 카운트업 애니메이션 시작",
      feedback: "성공 햅틱 (success notification)"
    },
    {
      time: "500ms",
      trigger: "점수 업데이트 완료",
      action: "전체 화면에 잠시 체크마크 표시",
      feedback: "none"
    },
    {
      time: "800ms",
      trigger: "다음 액션 준비",
      action: "되돌리기 버튼 5초간 표시 + 다음 게임 정보",
      feedback: "none"
    }
  ],
  
  // 에러 방지 및 복구
  errorHandling: {
    prevention: {
      doubleTap: "500ms 내 중복 터치 무시",
      accidentalTouch: "터치 면적이 너무 작으면 무시",
      networkError: "로컬에 저장 후 나중에 동기화"
    },
    
    recovery: {
      undoButton: "5초간 '되돌리기' 버튼 표시",
      undoFeedback: "되돌리기 시 역방향 애니메이션",
      confirmation: "중요한 경기(결승)에서만 확인 다이얼로그"
    }
  }
};
```

### 3. 체크인 인터랙션
```javascript
const checkinInteraction = {
  // 감정적 맥락
  emotionalContext: {
    arrival: "체육관 도착의 설렘",
    belonging: "소속감과 환영받는 느낌",
    readiness: "게임 준비 완료"
  },
  
  // QR 스캔 vs 버튼 체크인
  dualFlow: {
    qr: {
      sequence: [
        {
          time: "0ms",
          action: "카메라 화면 표시 + QR 가이드라인",
          feedback: "카메라 활성화 사운드"
        },
        {
          time: "1000ms", // QR 인식 시
          action: "인식 성공 애니메이션 (녹색 체크)",
          feedback: "성공 사운드 + 강한 햅틱"
        },
        {
          time: "1200ms",
          action: "환영 메시지 + 개인화된 인사",
          feedback: "none"
        }
      ]
    },
    
    button: {
      sequence: [
        {
          time: "0ms",
          action: "'도착 확인' 큰 버튼 터치",
          feedback: "즉시 햅틱"
        },
        {
          time: "100ms",
          action: "위치 확인 + 시간 검증",
          feedback: "로딩 인디케이터"
        },
        {
          time: "800ms",
          action: "체크인 완료 + 환영 메시지",
          feedback: "성공 사운드 + 햅틱"
        }
      ]
    }
  },
  
  // 개인화된 환영 메시지
  personalizedWelcome: {
    newbie: {
      message: "철수님 환영합니다! 오늘도 함께 즐겨요 🏸",
      additionalInfo: "오늘은 12명이 참석했어요",
      tip: "궁금한 것이 있으면 언제든 물어보세요!"
    },
    
    regular: {
      message: "영희님 오셨네요! 오늘 총 12명 참석",
      additionalInfo: "지난주보다 2명 더 많이 왔어요",
      gameInfo: "오늘은 A, B 코트 모두 사용해요"
    },
    
    organizer: {
      message: "관리님 수고하세요! 모든 준비 완료",
      additionalInfo: "체크인: 12/15명, 셔틀콕 준비됨",
      adminActions: "게임 시작 | 공지사항 | 비상연락망"
    }
  }
};
```

## 🎵 사운드 및 햅틱 피드백 설계

### 사운드 팔레트
```javascript
const soundDesign = {
  // 핵심 원칙
  principles: {
    optional: "모든 사운드는 선택사항 (무음 모드 존재)",
    contextual: "체육관 환경에 어울리는 소리",
    emotional: "감정을 강화하는 역할",
    brief: "0.5초 이내의 짧은 소리"
  },
  
  // 사운드 카테고리
  categories: {
    success: {
      participation: "부드러운 벨소리 (0.3초)",
      checkin: "환영하는 차임벨 (0.4초)",
      gameWin: "작은 승리 팡파레 (0.5초)",
      achievement: "성취 사운드 (0.6초)"
    },
    
    action: {
      buttonPress: "클릭 사운드 (0.1초)",
      scoreUpdate: "점수 올라가는 소리 (0.2초)",
      notification: "부드러운 알림음 (0.3초)"
    },
    
    error: {
      networkError: "부드러운 에러음 (0.3초)",
      validationError: "주의 사운드 (0.2초)"
    }
  },
  
  // 환경별 자동 조절
  adaptiveVolume: {
    quiet: "도서관, 집 (10% 볼륨)",
    normal: "일반 환경 (50% 볼륨)",
    gym: "체육관 (80% 볼륨, 더 명확한 음)"
  }
};
```

### 햅틱 피드백 전략
```javascript
const hapticDesign = {
  // iOS 햅틱 피드백 활용
  iosHaptics: {
    light: "가벼운 터치 확인 (버튼 호버)",
    medium: "일반적인 액션 (버튼 클릭)",
    heavy: "중요한 액션 (참가 신청, 점수 입력)",
    
    success: "성공적인 작업 완료",
    warning: "주의가 필요한 상황", 
    error: "오류 발생"
  },
  
  // Android 진동 패턴
  androidVibration: {
    short: "100ms 짧은 진동",
    medium: "200ms 중간 진동",
    long: "300ms 긴 진동",
    
    pattern: {
      success: [0, 100, 50, 100], // 두 번 짧게
      error: [0, 200, 100, 200],  // 두 번 길게
      notification: [0, 150]       // 한 번 중간
    }
  },
  
  // 상황별 햅틱 매핑
  contextualHaptics: {
    anticipation: "light (기대감을 해치지 않게)",
    focus: "heavy (확실한 피드백)",
    satisfaction: "success pattern (성취감 강화)",
    error: "error pattern (명확한 실패 알림)"
  }
};
```

## 🎨 애니메이션 설계

### 애니메이션 라이브러리
```javascript
const animationLibrary = {
  // 기본 타이밍
  timings: {
    instant: 100,   // 즉시 반응이 필요한 것
    quick: 200,     // 빠른 피드백
    normal: 300,    // 일반적인 전환
    slow: 500,      // 여유있는 애니메이션
    celebration: 800 // 축하/성취 애니메이션
  },
  
  // 이징 함수
  easings: {
    natural: "cubic-bezier(0.4, 0.0, 0.2, 1)", // Material Design
    bounce: "cubic-bezier(0.68, -0.55, 0.265, 1.55)",
    smooth: "cubic-bezier(0.25, 0.46, 0.45, 0.94)"
  },
  
  // 재사용 가능한 애니메이션
  reusableAnimations: {
    scalePress: {
      // 버튼 눌림 효과
      initial: { scale: 1 },
      pressed: { scale: 0.95 },
      released: { scale: 1 },
      timing: 100
    },
    
    fadeInUp: {
      // 카드 등장 효과
      initial: { opacity: 0, translateY: 30 },
      animate: { opacity: 1, translateY: 0 },
      timing: 300
    },
    
    countUp: {
      // 숫자 증가 효과
      duration: 500,
      ease: "easeOut",
      steps: 20
    },
    
    celebration: {
      // 성취 애니메이션
      scale: [1, 1.2, 1],
      rotate: [0, 10, -10, 0],
      duration: 800
    }
  }
};
```

### React Native Animated 구현
```javascript
const AnimationComponents = {
  // 스케일 프레스 애니메이션
  ScalePressable: ({ children, onPress }) => {
    const scaleAnim = useRef(new Animated.Value(1)).current;
    
    const handlePressIn = () => {
      Animated.timing(scaleAnim, {
        toValue: 0.95,
        duration: 100,
        useNativeDriver: true
      }).start();
    };
    
    const handlePressOut = () => {
      Animated.timing(scaleAnim, {
        toValue: 1,
        duration: 100,
        useNativeDriver: true
      }).start();
    };
    
    return (
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <TouchableOpacity
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          onPress={onPress}
          activeOpacity={1}
        >
          {children}
        </TouchableOpacity>
      </Animated.View>
    );
  },
  
  // 카운트업 애니메이션
  CountUpNumber: ({ from, to, duration = 500 }) => {
    const animatedValue = useRef(new Animated.Value(from)).current;
    const [displayValue, setDisplayValue] = useState(from);
    
    useEffect(() => {
      const listener = animatedValue.addListener(({ value }) => {
        setDisplayValue(Math.round(value));
      });
      
      Animated.timing(animatedValue, {
        toValue: to,
        duration,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: false
      }).start();
      
      return () => animatedValue.removeListener(listener);
    }, [to]);
    
    return <Text style={styles.countNumber}>{displayValue}</Text>;
  },
  
  // 성취 애니메이션
  AchievementBurst: ({ visible, children }) => {
    const scaleAnim = useRef(new Animated.Value(0)).current;
    const rotateAnim = useRef(new Animated.Value(0)).current;
    
    useEffect(() => {
      if (visible) {
        Animated.sequence([
          Animated.timing(scaleAnim, {
            toValue: 1.2,
            duration: 200,
            useNativeDriver: true
          }),
          Animated.timing(scaleAnim, {
            toValue: 1,
            duration: 300,
            useNativeDriver: true
          })
        ]).start();
        
        Animated.sequence([
          Animated.timing(rotateAnim, {
            toValue: 1,
            duration: 100,
            useNativeDriver: true
          }),
          Animated.timing(rotateAnim, {
            toValue: -1,
            duration: 100,
            useNativeDriver: true
          }),
          Animated.timing(rotateAnim, {
            toValue: 0,
            duration: 100,
            useNativeDriver: true
          })
        ]).start();
      }
    }, [visible]);
    
    const rotate = rotateAnim.interpolate({
      inputRange: [-1, 1],
      outputRange: ['-10deg', '10deg']
    });
    
    return (
      <Animated.View 
        style={{
          transform: [
            { scale: scaleAnim },
            { rotate }
          ]
        }}
      >
        {children}
      </Animated.View>
    );
  }
};
```

## 🔄 상태 기반 인터랙션

### 앱 상태별 인터랙션 변화
```javascript
const stateBasedInteractions = {
  // 게임 전 (참가 신청 시기)
  beforeGame: {
    mood: "기대감, 설렘",
    interactions: {
      speed: "보통 속도 (300ms)",
      feedback: "부드럽고 격려하는",
      colors: "밝고 활기찬",
      sounds: "경쾌한 톤"
    }
  },
  
  // 게임 당일
  gameDay: {
    mood: "긴장감, 준비성",
    interactions: {
      speed: "빠른 속도 (200ms)",
      feedback: "명확하고 확실한",
      colors: "강조색 중심",
      sounds: "명확한 피드백"
    }
  },
  
  // 게임 중
  duringGame: {
    mood: "집중, 몰입",
    interactions: {
      speed: "즉시 반응 (100ms)",
      feedback: "강력하고 간결한",
      colors: "고대비",
      sounds: "최소한 또는 없음"
    }
  },
  
  // 게임 후
  afterGame: {
    mood: "만족감, 여유",
    interactions: {
      speed: "여유로운 (500ms)",
      feedback: "축하와 성취감",
      colors: "따뜻하고 만족스러운",
      sounds: "성취감을 주는"
    }
  }
};
```

## 🧪 인터랙션 테스트 계획

### A/B 테스트 시나리오
```javascript
const interactionTests = {
  // 참가 버튼 피드백 비교
  participationFeedback: {
    versionA: "햅틱만",
    versionB: "햅틱 + 사운드", 
    versionC: "햅틱 + 사운드 + 애니메이션",
    
    metrics: [
      "완료율",
      "사용자 만족도",
      "재사용 의도",
      "실수 발생률"
    ]
  },
  
  // 점수 입력 방식 비교
  scoreInputMethod: {
    versionA: "큰 버튼 2개",
    versionB: "스와이프 제스처",
    versionC: "음성 입력",
    
    testConditions: [
      "일반 상황",
      "시끄러운 체육관",
      "땀에 젖은 손",
      "급한 상황"
    ]
  }
};
```

## 🔄 다음 단계

이제 **프로토타입_04: 실제 테스트 시나리오**를 작성하여 체육관 현장에서 실제로 테스트할 수 있는 구체적인 계획을 수립하겠습니다.

**완성된 설계 요소:**
- ✅ 감정-액션 매핑 체계
- ✅ 핵심 마이크로 인터랙션 상세 설계
- ✅ 사운드 및 햅틱 피드백 전략
- ✅ 애니메이션 라이브러리 구조
- ✅ 상태별 인터랙션 변화 체계

**다음 우선순위:**
1. 실제 체육관 테스트 시나리오
2. 사용자 인터뷰 가이드라인
3. 프로토타입 개선 방향성