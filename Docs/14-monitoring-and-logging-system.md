# ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ê³„

## ëª©ì°¨
1. [ëª¨ë‹ˆí„°ë§ ì „ëµ ê°œìš”](#ëª¨ë‹ˆí„°ë§-ì „ëµ-ê°œìš”)
2. [ì• í”Œë¦¬ì¼€ì´ì…˜ ëª¨ë‹ˆí„°ë§](#ì• í”Œë¦¬ì¼€ì´ì…˜-ëª¨ë‹ˆí„°ë§)
3. [ì¸í”„ë¼ ëª¨ë‹ˆí„°ë§](#ì¸í”„ë¼-ëª¨ë‹ˆí„°ë§)
4. [ë¡œê¹… ì‹œìŠ¤í…œ](#ë¡œê¹…-ì‹œìŠ¤í…œ)
5. [ì•Œë¦¼ ë° ê²½ê³  ì‹œìŠ¤í…œ](#ì•Œë¦¼-ë°-ê²½ê³ -ì‹œìŠ¤í…œ)
6. [ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§](#ì„±ëŠ¥-ëª¨ë‹ˆí„°ë§)
7. [ì‚¬ìš©ì í–‰ë™ ë¶„ì„](#ì‚¬ìš©ì-í–‰ë™-ë¶„ì„)
8. [ë³´ì•ˆ ëª¨ë‹ˆí„°ë§](#ë³´ì•ˆ-ëª¨ë‹ˆí„°ë§)
9. [ëŒ€ì‹œë³´ë“œ ë° ì‹œê°í™”](#ëŒ€ì‹œë³´ë“œ-ë°-ì‹œê°í™”)

## ëª¨ë‹ˆí„°ë§ ì „ëµ ê°œìš”

### ëª¨ë‹ˆí„°ë§ ì² í•™
```
Golden Signals:
1. Latency (ì§€ì—°ì‹œê°„) - ìš”ì²­ ì²˜ë¦¬ ì‹œê°„
2. Traffic (íŠ¸ë˜í”½) - ì´ˆë‹¹ ìš”ì²­ ìˆ˜
3. Errors (ì˜¤ë¥˜) - ì‹¤íŒ¨ìœ¨
4. Saturation (í¬í™”ë„) - ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥ 
```

### ëª¨ë‹ˆí„°ë§ ê³„ì¸µ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ì‚¬ìš©ì ê²½í—˜ ëª¨ë‹ˆí„°ë§           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ì• í”Œë¦¬ì¼€ì´ì…˜ ëª¨ë‹ˆí„°ë§          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ì¸í”„ë¼ ëª¨ë‹ˆí„°ë§              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           ë„¤íŠ¸ì›Œí¬ ëª¨ë‹ˆí„°ë§             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì£¼ìš” ë©”íŠ¸ë¦­ ì¹´í…Œê³ ë¦¬

#### ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­
- ì¼ì¼ í™œì„± ì‚¬ìš©ì (DAU)
- ê²Œì„ ìƒì„±/ì°¸ê°€ ìœ¨
- Band API ë™ê¸°í™” ì„±ê³µë¥ 
- ì‚¬ìš©ì ì„¸ì…˜ ì‹œê°„

#### ê¸°ìˆ  ë©”íŠ¸ë¦­
- API ì‘ë‹µ ì‹œê°„
- ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì„±ëŠ¥
- ë©”ëª¨ë¦¬/CPU ì‚¬ìš©ë¥ 
- ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„

#### ì„œë¹„ìŠ¤ í’ˆì§ˆ ë©”íŠ¸ë¦­
- ê°€ìš©ì„± (Availability)
- ì•ˆì •ì„± (Reliability)
- í™•ì¥ì„± (Scalability)
- ë³´ì•ˆ (Security)

## ì• í”Œë¦¬ì¼€ì´ì…˜ ëª¨ë‹ˆí„°ë§

### Node.js ë°±ì—”ë“œ ëª¨ë‹ˆí„°ë§

#### Express.js ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
```javascript
// src/middleware/monitoring.js
import prometheus from 'prom-client';
import responseTime from 'response-time';
import { createLogger } from '../utils/logger';

const logger = createLogger('monitoring');

// Prometheus ë©”íŠ¸ë¦­ ì •ì˜
const httpRequestDuration = new prometheus.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

const httpRequestTotal = new prometheus.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

const activeConnections = new prometheus.Gauge({
  name: 'active_connections',
  help: 'Number of active connections'
});

// ë¯¸ë“¤ì›¨ì–´ í•¨ìˆ˜
export const metricsMiddleware = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    const route = req.route ? req.route.path : req.path;
    
    httpRequestDuration
      .labels(req.method, route, res.statusCode)
      .observe(duration);
    
    httpRequestTotal
      .labels(req.method, route, res.statusCode)
      .inc();
    
    // ì—ëŸ¬ ë¡œê¹…
    if (res.statusCode >= 400) {
      logger.error('HTTP Error', {
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        duration,
        userAgent: req.get('User-Agent'),
        ip: req.ip
      });
    }
  });
  
  next();
};

// ì»¤ìŠ¤í…€ ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­
export const gameMetrics = {
  gamesCreated: new prometheus.Counter({
    name: 'games_created_total',
    help: 'Total number of games created',
    labelNames: ['creator_role']
  }),
  
  gameParticipations: new prometheus.Counter({
    name: 'game_participations_total',
    help: 'Total number of game participations',
    labelNames: ['game_type']
  }),
  
  bandApiCalls: new prometheus.Counter({
    name: 'band_api_calls_total',
    help: 'Total number of Band API calls',
    labelNames: ['endpoint', 'status']
  }),
  
  activeSessions: new prometheus.Gauge({
    name: 'active_user_sessions',
    help: 'Number of active user sessions'
  })
};
```

#### Health Check ì—”ë“œí¬ì¸íŠ¸
```javascript
// src/routes/health.js
import express from 'express';
import mongoose from 'mongoose';
import redis from '../config/redis';
import { BandAPI } from '../services/bandAPI';

const router = express.Router();

// ê¸°ë³¸ í—¬ìŠ¤ ì²´í¬
router.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.npm_package_version
  });
});

// ìƒì„¸ í—¬ìŠ¤ ì²´í¬
router.get('/health/detailed', async (req, res) => {
  const checks = {
    database: 'unknown',
    redis: 'unknown',
    bandAPI: 'unknown',
    memory: 'unknown'
  };

  try {
    // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í™•ì¸
    if (mongoose.connection.readyState === 1) {
      await mongoose.connection.db.admin().ping();
      checks.database = 'healthy';
    } else {
      checks.database = 'unhealthy';
    }
  } catch (error) {
    checks.database = 'unhealthy';
  }

  try {
    // Redis ì—°ê²° í™•ì¸
    await redis.ping();
    checks.redis = 'healthy';
  } catch (error) {
    checks.redis = 'unhealthy';
  }

  try {
    // Band API ì—°ê²° í™•ì¸
    await BandAPI.healthCheck();
    checks.bandAPI = 'healthy';
  } catch (error) {
    checks.bandAPI = 'unhealthy';
  }

  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
  const memoryUsage = process.memoryUsage();
  const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;
  checks.memory = memoryUsagePercent < 80 ? 'healthy' : 'warning';

  const overallStatus = Object.values(checks).every(status => 
    status === 'healthy' || status === 'warning'
  ) ? 'healthy' : 'unhealthy';

  res.status(overallStatus === 'healthy' ? 200 : 503).json({
    status: overallStatus,
    checks,
    timestamp: new Date().toISOString(),
    memory: {
      used: Math.round(memoryUsage.heapUsed / 1024 / 1024),
      total: Math.round(memoryUsage.heapTotal / 1024 / 1024),
      percentage: Math.round(memoryUsagePercent)
    }
  });
});

export default router;
```

### React Native í´ë¼ì´ì–¸íŠ¸ ëª¨ë‹ˆí„°ë§

#### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
```javascript
// src/services/performanceMonitoring.js
import crashlytics from '@react-native-firebase/crashlytics';
import analytics from '@react-native-firebase/analytics';
import perf from '@react-native-firebase/perf';

class PerformanceMonitoringService {
  constructor() {
    this.metrics = new Map();
    this.traces = new Map();
  }

  // í™”ë©´ ë¡œë”© ì‹œê°„ ì¸¡ì •
  startScreenTrace(screenName) {
    const trace = perf().newTrace(`screen_${screenName}_load`);
    trace.start();
    this.traces.set(screenName, trace);
    
    return {
      stop: () => {
        const existingTrace = this.traces.get(screenName);
        if (existingTrace) {
          existingTrace.stop();
          this.traces.delete(screenName);
        }
      }
    };
  }

  // API í˜¸ì¶œ ì‹œê°„ ì¸¡ì •
  async trackAPICall(endpoint, apiCall) {
    const trace = perf().newTrace(`api_${endpoint.replace(/\//g, '_')}`);
    trace.start();
    
    const startTime = Date.now();
    
    try {
      const result = await apiCall();
      
      trace.putAttribute('status', 'success');
      trace.putMetric('duration', Date.now() - startTime);
      
      // ì„±ê³µ ì´ë²¤íŠ¸ ë¡œê¹…
      await analytics().logEvent('api_call_success', {
        endpoint,
        duration: Date.now() - startTime
      });
      
      return result;
    } catch (error) {
      trace.putAttribute('status', 'error');
      trace.putAttribute('error_type', error.name);
      trace.putMetric('duration', Date.now() - startTime);
      
      // ì—ëŸ¬ ì´ë²¤íŠ¸ ë¡œê¹…
      await analytics().logEvent('api_call_error', {
        endpoint,
        error_message: error.message,
        duration: Date.now() - startTime
      });
      
      // Crashlyticsì— ì—ëŸ¬ ë³´ê³ 
      crashlytics().recordError(error);
      
      throw error;
    } finally {
      trace.stop();
    }
  }

  // ì‚¬ìš©ì í–‰ë™ ì¶”ì 
  async trackUserAction(action, parameters = {}) {
    try {
      await analytics().logEvent(action, {
        ...parameters,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.warn('Analytics tracking failed:', error);
    }
  }

  // ì•± ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
  collectAppMetrics() {
    const metrics = {
      memory: this.getMemoryUsage(),
      battery: this.getBatteryLevel(),
      network: this.getNetworkInfo(),
      device: this.getDeviceInfo()
    };

    return metrics;
  }

  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (React Native ë©”ëª¨ë¦¬ ì •ë³´ëŠ” ì œí•œì )
  getMemoryUsage() {
    // í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
    return {
      timestamp: Date.now(),
      // iOS/Android ë„¤ì´í‹°ë¸Œ ëª¨ë“ˆ í•„ìš”
      estimated: 'native_module_required'
    };
  }

  // ë°°í„°ë¦¬ ë ˆë²¨
  getBatteryLevel() {
    // react-native-device-info ì‚¬ìš©
    return {
      timestamp: Date.now(),
      level: 'device_info_module_required'
    };
  }

  // ë„¤íŠ¸ì›Œí¬ ì •ë³´
  getNetworkInfo() {
    // @react-native-community/netinfo ì‚¬ìš©
    return {
      timestamp: Date.now(),
      type: 'netinfo_module_required'
    };
  }

  // ë””ë°”ì´ìŠ¤ ì •ë³´
  getDeviceInfo() {
    return {
      platform: Platform.OS,
      version: Platform.Version,
      timestamp: Date.now()
    };
  }

  // ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­ ì„¤ì •
  setCustomMetric(name, value, attributes = {}) {
    this.metrics.set(name, {
      value,
      attributes,
      timestamp: Date.now()
    });
  }

  // ì—ëŸ¬ ë³´ê³ 
  reportError(error, context = {}) {
    crashlytics().recordError(error);
    crashlytics().setAttributes(context);
  }

  // ì‚¬ìš©ì ì •ë³´ ì„¤ì •
  setUser(userId, attributes = {}) {
    crashlytics().setUserId(userId);
    analytics().setUserId(userId);
    
    Object.entries(attributes).forEach(([key, value]) => {
      analytics().setUserProperty(key, value);
    });
  }
}

export const performanceMonitoring = new PerformanceMonitoringService();
```

#### ì‚¬ìš© ì˜ˆì‹œ
```javascript
// src/screens/HomeScreen.js
import React, { useEffect } from 'react';
import { performanceMonitoring } from '../services/performanceMonitoring';

export const HomeScreen = () => {
  useEffect(() => {
    // í™”ë©´ ë¡œë”© ì‹œê°„ ì¸¡ì •
    const trace = performanceMonitoring.startScreenTrace('home');
    
    const loadData = async () => {
      try {
        // API í˜¸ì¶œ ì„±ëŠ¥ ì¸¡ì •
        const games = await performanceMonitoring.trackAPICall(
          '/api/games',
          () => gameAPI.getGames()
        );
        
        // ì‚¬ìš©ì í–‰ë™ ì¶”ì 
        await performanceMonitoring.trackUserAction('home_screen_loaded', {
          games_count: games.length
        });
        
      } catch (error) {
        performanceMonitoring.reportError(error, {
          screen: 'home',
          action: 'load_games'
        });
      } finally {
        trace.stop();
      }
    };

    loadData();
  }, []);

  return (
    // ì»´í¬ë„ŒíŠ¸ ë Œë”ë§
  );
};
```

## ì¸í”„ë¼ ëª¨ë‹ˆí„°ë§

### AWS CloudWatch ì„¤ì •

#### ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­ ì „ì†¡
```javascript
// src/utils/cloudwatch.js
import AWS from 'aws-sdk';

const cloudwatch = new AWS.CloudWatch({
  region: process.env.AWS_REGION
});

class CloudWatchMetrics {
  constructor(namespace = 'DongBaeJul') {
    this.namespace = namespace;
  }

  async putMetric(metricName, value, unit = 'Count', dimensions = []) {
    const params = {
      Namespace: this.namespace,
      MetricData: [{
        MetricName: metricName,
        Value: value,
        Unit: unit,
        Dimensions: dimensions,
        Timestamp: new Date()
      }]
    };

    try {
      await cloudwatch.putMetricData(params).promise();
    } catch (error) {
      console.error('CloudWatch metric failed:', error);
    }
  }

  async putCustomMetrics(metrics) {
    const metricData = metrics.map(metric => ({
      MetricName: metric.name,
      Value: metric.value,
      Unit: metric.unit || 'Count',
      Dimensions: metric.dimensions || [],
      Timestamp: new Date()
    }));

    const params = {
      Namespace: this.namespace,
      MetricData: metricData
    };

    try {
      await cloudwatch.putMetricData(params).promise();
    } catch (error) {
      console.error('CloudWatch batch metrics failed:', error);
    }
  }
}

export const cloudwatchMetrics = new CloudWatchMetrics();
```

#### Infrastructure as Code (CloudFormation)
```yaml
# monitoring-stack.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'DongBaeJul Monitoring Stack'

Resources:
  # CloudWatch Dashboard
  MonitoringDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: DongBaeJul-Monitoring
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "properties": {
                "metrics": [
                  ["AWS/ApplicationELB", "RequestCount", "LoadBalancer", "${LoadBalancer}"],
                  [".", "TargetResponseTime", ".", "."],
                  [".", "HTTPCode_Target_4XX_Count", ".", "."],
                  [".", "HTTPCode_Target_5XX_Count", ".", "."]
                ],
                "period": 300,
                "stat": "Sum",
                "region": "ap-northeast-2",
                "title": "ALB Metrics"
              }
            },
            {
              "type": "metric",
              "properties": {
                "metrics": [
                  ["AWS/ECS", "CPUUtilization", "ServiceName", "${ECSService}"],
                  [".", "MemoryUtilization", ".", "."]
                ],
                "period": 300,
                "stat": "Average",
                "region": "ap-northeast-2",
                "title": "ECS Service Metrics"
              }
            }
          ]
        }

  # SNS Topic for Alerts
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: DongBaeJul-Alerts
      Subscription:
        - Protocol: email
          Endpoint: admin@dongbaejul.com
        - Protocol: https
          Endpoint: !Sub 'https://hooks.slack.com/services/${SlackWebhookPath}'

  # CloudWatch Alarms
  HighErrorRateAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: DongBaeJul-HighErrorRate
      AlarmDescription: High error rate detected
      MetricName: HTTPCode_Target_5XX_Count
      Namespace: AWS/ApplicationELB
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 10
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref AlertTopic
      Dimensions:
        - Name: LoadBalancer
          Value: !Ref LoadBalancer

  HighResponseTimeAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: DongBaeJul-HighResponseTime
      AlarmDescription: High response time detected
      MetricName: TargetResponseTime
      Namespace: AWS/ApplicationELB
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 2.0
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref AlertTopic
      Dimensions:
        - Name: LoadBalancer
          Value: !Ref LoadBalancer

  DatabaseConnectionsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: DongBaeJul-HighDBConnections
      AlarmDescription: High database connections
      MetricName: DatabaseConnections
      Namespace: AWS/DocDB
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 80
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref AlertTopic
```

## ë¡œê¹… ì‹œìŠ¤í…œ

### êµ¬ì¡°í™”ëœ ë¡œê¹…

#### Winston ë¡œê±° ì„¤ì •
```javascript
// src/utils/logger.js
import winston from 'winston';
import { ElasticsearchTransport } from 'winston-elasticsearch';

const esTransportOpts = {
  level: 'info',
  clientOpts: {
    node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200'
  },
  index: 'dongbaejul-logs',
  indexTemplate: {
    name: 'dongbaejul-logs-template',
    body: {
      index_patterns: ['dongbaejul-logs-*'],
      settings: {
        number_of_shards: 1,
        number_of_replicas: 1
      },
      mappings: {
        properties: {
          '@timestamp': { type: 'date' },
          level: { type: 'keyword' },
          message: { type: 'text' },
          service: { type: 'keyword' },
          userId: { type: 'keyword' },
          requestId: { type: 'keyword' },
          action: { type: 'keyword' },
          duration: { type: 'integer' },
          error: {
            properties: {
              name: { type: 'keyword' },
              message: { type: 'text' },
              stack: { type: 'text' }
            }
          }
        }
      }
    }
  }
};

const createLogger = (service) => {
  const transports = [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ];

  // í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” Elasticsearch ì¶”ê°€
  if (process.env.NODE_ENV === 'production') {
    transports.push(new ElasticsearchTransport(esTransportOpts));
  }

  return winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      winston.format.json(),
      winston.format.printf(({ timestamp, level, message, service: svc, ...meta }) => {
        return JSON.stringify({
          timestamp,
          level,
          message,
          service: service || svc,
          ...meta
        });
      })
    ),
    defaultMeta: { service },
    transports
  });
};

export { createLogger };

// íŠ¹ì • ë„ë©”ì¸ë³„ ë¡œê±°
export const gameLogger = createLogger('game');
export const authLogger = createLogger('auth');
export const bandAPILogger = createLogger('band-api');
export const socketLogger = createLogger('socket');
```

#### ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
```javascript
// src/middleware/logging.js
import { v4 as uuidv4 } from 'uuid';
import { createLogger } from '../utils/logger';

const logger = createLogger('http');

export const requestLoggingMiddleware = (req, res, next) => {
  // ìš”ì²­ ID ìƒì„±
  req.id = uuidv4();
  res.setHeader('X-Request-ID', req.id);

  const startTime = Date.now();
  
  // ìš”ì²­ ë¡œê¹…
  logger.info('Request started', {
    requestId: req.id,
    method: req.method,
    url: req.url,
    userAgent: req.get('User-Agent'),
    ip: req.ip,
    userId: req.user?.id
  });

  // ì‘ë‹µ ì™„ë£Œ ì‹œ ë¡œê¹…
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    
    const logData = {
      requestId: req.id,
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration,
      userId: req.user?.id
    };

    if (res.statusCode >= 400) {
      logger.error('Request failed', logData);
    } else {
      logger.info('Request completed', logData);
    }
  });

  next();
};

// ì—ëŸ¬ ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
export const errorLoggingMiddleware = (err, req, res, next) => {
  logger.error('Unhandled error', {
    requestId: req.id,
    error: {
      name: err.name,
      message: err.message,
      stack: err.stack
    },
    method: req.method,
    url: req.url,
    userId: req.user?.id
  });

  next(err);
};
```

#### ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë¡œê¹…
```javascript
// src/services/gameService.js
import { gameLogger } from '../utils/logger';

export class GameService {
  async createGame(gameData, userId) {
    const startTime = Date.now();
    
    gameLogger.info('Game creation started', {
      userId,
      gameTitle: gameData.title,
      maxParticipants: gameData.maxParticipants
    });

    try {
      const game = await Game.create({
        ...gameData,
        creator: userId
      });

      // Band API ì•Œë¦¼
      await this.notifyBandGroup(game);

      gameLogger.info('Game created successfully', {
        gameId: game.id,
        userId,
        duration: Date.now() - startTime
      });

      return game;
    } catch (error) {
      gameLogger.error('Game creation failed', {
        userId,
        error: {
          name: error.name,
          message: error.message
        },
        duration: Date.now() - startTime
      });
      
      throw error;
    }
  }

  async joinGame(gameId, userId) {
    gameLogger.info('Game join attempt', { gameId, userId });

    try {
      const game = await Game.findById(gameId);
      
      if (!game) {
        gameLogger.warn('Game not found', { gameId, userId });
        throw new Error('Game not found');
      }

      if (game.participants.includes(userId)) {
        gameLogger.warn('User already in game', { gameId, userId });
        throw new Error('Already joined');
      }

      game.participants.push(userId);
      await game.save();

      gameLogger.info('User joined game', {
        gameId,
        userId,
        participantCount: game.participants.length
      });

      return game;
    } catch (error) {
      gameLogger.error('Game join failed', {
        gameId,
        userId,
        error: {
          name: error.name,
          message: error.message
        }
      });
      
      throw error;
    }
  }
}
```

### ë¡œê·¸ ì§‘ê³„ ë° ë¶„ì„

#### ELK Stack ì„¤ì • (docker-compose)
```yaml
# docker-compose-elk.yml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data

  logstash:
    image: docker.elastic.co/logstash/logstash:8.5.0
    container_name: logstash
    ports:
      - "5044:5044"
      - "9600:9600"
    volumes:
      - ./logstash/config:/usr/share/logstash/config:ro
      - ./logstash/pipeline:/usr/share/logstash/pipeline:ro
    depends_on:
      - elasticsearch

  kibana:
    image: docker.elastic.co/kibana/kibana:8.5.0
    container_name: kibana
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

volumes:
  elasticsearch-data:
```

#### Logstash íŒŒì´í”„ë¼ì¸ ì„¤ì •
```ruby
# logstash/pipeline/logstash.conf
input {
  beats {
    port => 5044
  }
  
  http {
    port => 8080
    codec => json
  }
}

filter {
  if [fields][service] == "dongbaejul-backend" {
    json {
      source => "message"
    }
    
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    if [error] {
      mutate {
        add_tag => ["error"]
      }
    }
    
    if [level] == "error" {
      mutate {
        add_tag => ["alert"]
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "dongbaejul-logs-%{+YYYY.MM.dd}"
  }
  
  if "alert" in [tags] {
    http {
      url => "${SLACK_WEBHOOK_URL}"
      http_method => "post"
      content_type => "application/json"
      format => "message"
      message => '{"text": "ğŸš¨ Error in DongBaeJul: %{message}"}'
    }
  }
}
```

## ì•Œë¦¼ ë° ê²½ê³  ì‹œìŠ¤í…œ

### Slack í†µí•©

#### Slack ì•Œë¦¼ ì„œë¹„ìŠ¤
```javascript
// src/services/alertService.js
import axios from 'axios';
import { createLogger } from '../utils/logger';

const logger = createLogger('alerts');

class AlertService {
  constructor() {
    this.slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;
    this.channels = {
      critical: process.env.SLACK_CRITICAL_CHANNEL || '#alerts-critical',
      warning: process.env.SLACK_WARNING_CHANNEL || '#alerts-warning',
      info: process.env.SLACK_INFO_CHANNEL || '#alerts-info'
    };
  }

  async sendSlackAlert(severity, title, message, fields = []) {
    if (!this.slackWebhookUrl) {
      logger.warn('Slack webhook URL not configured');
      return;
    }

    const colors = {
      critical: '#FF0000',
      warning: '#FFA500',
      info: '#00FF00'
    };

    const payload = {
      channel: this.channels[severity] || this.channels.info,
      username: 'DongBaeJul Monitor',
      icon_emoji: ':warning:',
      attachments: [{
        color: colors[severity],
        title,
        text: message,
        fields,
        footer: 'DongBaeJul Monitoring',
        ts: Math.floor(Date.now() / 1000)
      }]
    };

    try {
      await axios.post(this.slackWebhookUrl, payload);
      logger.info('Slack alert sent', { severity, title });
    } catch (error) {
      logger.error('Failed to send Slack alert', {
        error: error.message,
        severity,
        title
      });
    }
  }

  async sendErrorAlert(error, context = {}) {
    const fields = Object.entries(context).map(([key, value]) => ({
      title: key,
      value: String(value),
      short: true
    }));

    await this.sendSlackAlert(
      'critical',
      `Error in ${context.service || 'Unknown Service'}`,
      error.message,
      fields
    );
  }

  async sendPerformanceAlert(metric, value, threshold, context = {}) {
    const fields = [
      { title: 'Metric', value: metric, short: true },
      { title: 'Current Value', value: String(value), short: true },
      { title: 'Threshold', value: String(threshold), short: true },
      ...Object.entries(context).map(([key, value]) => ({
        title: key,
        value: String(value),
        short: true
      }))
    ];

    await this.sendSlackAlert(
      'warning',
      'Performance Alert',
      `${metric} exceeded threshold`,
      fields
    );
  }

  async sendBusinessAlert(event, data = {}) {
    const fields = Object.entries(data).map(([key, value]) => ({
      title: key,
      value: String(value),
      short: true
    }));

    await this.sendSlackAlert(
      'info',
      'Business Event',
      event,
      fields
    );
  }
}

export const alertService = new AlertService();
```

### ì´ë©”ì¼ ì•Œë¦¼

#### ì´ë©”ì¼ ì„œë¹„ìŠ¤ (AWS SES)
```javascript
// src/services/emailService.js
import AWS from 'aws-sdk';
import { createLogger } from '../utils/logger';

const logger = createLogger('email');
const ses = new AWS.SES({ region: process.env.AWS_REGION });

class EmailService {
  constructor() {
    this.fromEmail = process.env.FROM_EMAIL || 'noreply@dongbaejul.com';
    this.adminEmails = (process.env.ADMIN_EMAILS || '').split(',');
  }

  async sendAlert(subject, htmlBody, textBody) {
    if (this.adminEmails.length === 0) {
      logger.warn('No admin emails configured');
      return;
    }

    const params = {
      Source: this.fromEmail,
      Destination: {
        ToAddresses: this.adminEmails
      },
      Message: {
        Subject: {
          Data: `[DongBaeJul Alert] ${subject}`,
          Charset: 'UTF-8'
        },
        Body: {
          Html: {
            Data: htmlBody,
            Charset: 'UTF-8'
          },
          Text: {
            Data: textBody,
            Charset: 'UTF-8'
          }
        }
      }
    };

    try {
      await ses.sendEmail(params).promise();
      logger.info('Alert email sent', { subject, recipients: this.adminEmails });
    } catch (error) {
      logger.error('Failed to send alert email', {
        error: error.message,
        subject
      });
    }
  }

  async sendCriticalAlert(title, message, details = {}) {
    const htmlBody = `
      <h2 style="color: #FF0000;">ğŸš¨ Critical Alert</h2>
      <h3>${title}</h3>
      <p>${message}</p>
      <h4>Details:</h4>
      <ul>
        ${Object.entries(details).map(([key, value]) => 
          `<li><strong>${key}:</strong> ${value}</li>`
        ).join('')}
      </ul>
      <p><small>Timestamp: ${new Date().toISOString()}</small></p>
    `;

    const textBody = `
CRITICAL ALERT

${title}

${message}

Details:
${Object.entries(details).map(([key, value]) => `${key}: ${value}`).join('\n')}

Timestamp: ${new Date().toISOString()}
    `;

    await this.sendAlert(title, htmlBody, textBody);
  }
}

export const emailService = new EmailService();
```

## ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### APM (Application Performance Monitoring)

#### New Relic í†µí•©
```javascript
// src/utils/newrelic.js
import newrelic from 'newrelic';

export const trackCustomMetric = (name, value) => {
  newrelic.recordCustomMetric(name, value);
};

export const trackCustomEvent = (eventType, attributes) => {
  newrelic.recordCustomEvent(eventType, attributes);
};

export const addCustomAttribute = (key, value) => {
  newrelic.addCustomAttribute(key, value);
};

// ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­ ì¶”ì 
export const trackBusinessMetrics = {
  gameCreated: (gameData) => {
    trackCustomEvent('GameCreated', {
      gameType: gameData.type,
      maxParticipants: gameData.maxParticipants,
      creatorRole: gameData.creatorRole
    });
  },

  userJoinedGame: (gameId, userId) => {
    trackCustomEvent('UserJoinedGame', {
      gameId,
      userId
    });
  },

  bandAPICall: (endpoint, duration, success) => {
    trackCustomMetric('Custom/BandAPI/Duration', duration);
    trackCustomEvent('BandAPICall', {
      endpoint,
      duration,
      success
    });
  }
};
```

### ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

#### MongoDB ëª¨ë‹ˆí„°ë§
```javascript
// src/utils/mongoMonitoring.js
import mongoose from 'mongoose';
import { createLogger } from './logger';
import { cloudwatchMetrics } from './cloudwatch';

const logger = createLogger('mongo-monitoring');

// ìŠ¬ë¡œìš° ì¿¼ë¦¬ ëª¨ë‹ˆí„°ë§
mongoose.set('debug', (coll, method, query, doc, options) => {
  const start = Date.now();
  
  // ì¿¼ë¦¬ ì‹¤í–‰ í›„ ì¸¡ì •
  setImmediate(() => {
    const duration = Date.now() - start;
    
    if (duration > 1000) { // 1ì´ˆ ì´ìƒ ê±¸ë¦° ì¿¼ë¦¬
      logger.warn('Slow query detected', {
        collection: coll,
        method,
        query: JSON.stringify(query),
        duration
      });
      
      // CloudWatch ë©”íŠ¸ë¦­ ì „ì†¡
      cloudwatchMetrics.putMetric('SlowQueryCount', 1, 'Count', [
        { Name: 'Collection', Value: coll },
        { Name: 'Method', Value: method }
      ]);
    }
    
    // ëª¨ë“  ì¿¼ë¦¬ ì„±ëŠ¥ ë©”íŠ¸ë¦­
    cloudwatchMetrics.putMetric('QueryDuration', duration, 'Milliseconds', [
      { Name: 'Collection', Value: coll },
      { Name: 'Method', Value: method }
    ]);
  });
});

// ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
mongoose.connection.on('connected', () => {
  logger.info('MongoDB connected');
  cloudwatchMetrics.putMetric('MongoDBConnection', 1, 'Count');
});

mongoose.connection.on('error', (err) => {
  logger.error('MongoDB connection error', { error: err.message });
  cloudwatchMetrics.putMetric('MongoDBConnectionError', 1, 'Count');
});

mongoose.connection.on('disconnected', () => {
  logger.warn('MongoDB disconnected');
  cloudwatchMetrics.putMetric('MongoDBConnection', 0, 'Count');
});

// ì—°ê²° í’€ ëª¨ë‹ˆí„°ë§
setInterval(() => {
  const stats = mongoose.connection.db?.stats();
  if (stats) {
    cloudwatchMetrics.putCustomMetrics([
      { name: 'MongoDBConnections', value: stats.connections || 0 },
      { name: 'MongoDBDataSize', value: stats.dataSize || 0, unit: 'Bytes' },
      { name: 'MongoDBIndexSize', value: stats.indexSize || 0, unit: 'Bytes' }
    ]);
  }
}, 60000); // 1ë¶„ë§ˆë‹¤
```

## ì‚¬ìš©ì í–‰ë™ ë¶„ì„

### Google Analytics 4 í†µí•©

#### React Native Analytics
```javascript
// src/services/analytics.js
import analytics from '@react-native-firebase/analytics';
import { createLogger } from '../utils/logger';

const logger = createLogger('analytics');

class AnalyticsService {
  constructor() {
    this.isEnabled = true;
  }

  async initialize() {
    try {
      await analytics().setAnalyticsCollectionEnabled(this.isEnabled);
      logger.info('Analytics initialized');
    } catch (error) {
      logger.error('Analytics initialization failed', { error: error.message });
    }
  }

  // í™”ë©´ ì¡°íšŒ ì¶”ì 
  async trackScreenView(screenName, screenClass) {
    try {
      await analytics().logScreenView({
        screen_name: screenName,
        screen_class: screenClass
      });
    } catch (error) {
      logger.error('Screen view tracking failed', { error: error.message });
    }
  }

  // ì‚¬ìš©ì í–‰ë™ ì¶”ì 
  async trackEvent(eventName, parameters = {}) {
    try {
      await analytics().logEvent(eventName, {
        ...parameters,
        timestamp: Date.now()
      });
    } catch (error) {
      logger.error('Event tracking failed', { error: error.message });
    }
  }

  // ì‚¬ìš©ì ì†ì„± ì„¤ì •
  async setUserProperties(properties) {
    try {
      for (const [key, value] of Object.entries(properties)) {
        await analytics().setUserProperty(key, String(value));
      }
    } catch (error) {
      logger.error('User properties setting failed', { error: error.message });
    }
  }

  // ë¹„ì¦ˆë‹ˆìŠ¤ íŠ¹í™” ì´ë²¤íŠ¸
  async trackGameEvents(event, gameData = {}) {
    const events = {
      game_created: () => this.trackEvent('game_created', {
        game_type: gameData.type,
        max_participants: gameData.maxParticipants
      }),
      
      game_joined: () => this.trackEvent('game_joined', {
        game_id: gameData.id,
        participants_count: gameData.participantsCount
      }),
      
      game_left: () => this.trackEvent('game_left', {
        game_id: gameData.id,
        time_spent: gameData.timeSpent
      }),
      
      game_completed: () => this.trackEvent('game_completed', {
        game_id: gameData.id,
        duration: gameData.duration,
        participants_count: gameData.participantsCount
      })
    };

    if (events[event]) {
      await events[event]();
    }
  }

  // ë°´ë“œ ì—°ë™ ì´ë²¤íŠ¸
  async trackBandEvents(event, data = {}) {
    const events = {
      band_login_started: () => this.trackEvent('band_login_started'),
      band_login_completed: () => this.trackEvent('band_login_completed', {
        user_role: data.role
      }),
      band_sync_completed: () => this.trackEvent('band_sync_completed', {
        members_synced: data.membersCount,
        posts_synced: data.postsCount
      })
    };

    if (events[event]) {
      await events[event]();
    }
  }

  // ì•± ì‚¬ìš©ì„± ë©”íŠ¸ë¦­
  async trackUsabilityMetrics(metric, value, context = {}) {
    await this.trackEvent('usability_metric', {
      metric_name: metric,
      metric_value: value,
      ...context
    });
  }
}

export const analyticsService = new AnalyticsService();
```

### ì‚¬ìš©ì ì„¸ì…˜ ì¶”ì 

#### ì„¸ì…˜ ê´€ë¦¬ ì„œë¹„ìŠ¤
```javascript
// src/services/sessionTracking.js
import AsyncStorage from '@react-native-async-storage/async-storage';
import { analyticsService } from './analytics';
import { performanceMonitoring } from './performanceMonitoring';

class SessionTrackingService {
  constructor() {
    this.sessionStart = null;
    this.sessionId = null;
    this.interactions = [];
  }

  async startSession(userId) {
    this.sessionStart = Date.now();
    this.sessionId = `session_${userId}_${this.sessionStart}`;
    this.interactions = [];

    // ì„¸ì…˜ ì‹œì‘ ì´ë²¤íŠ¸
    await analyticsService.trackEvent('session_start', {
      session_id: this.sessionId,
      user_id: userId
    });

    // ì´ì „ ì„¸ì…˜ ë°ì´í„° ì „ì†¡
    await this.sendPendingSessionData();
  }

  async endSession(userId) {
    if (!this.sessionStart) return;

    const sessionDuration = Date.now() - this.sessionStart;
    
    const sessionData = {
      session_id: this.sessionId,
      user_id: userId,
      duration: sessionDuration,
      interactions_count: this.interactions.length,
      interactions: this.interactions.slice(-50) // ìµœê·¼ 50ê°œ ìƒí˜¸ì‘ìš©ë§Œ
    };

    // ì„¸ì…˜ ì¢…ë£Œ ì´ë²¤íŠ¸
    await analyticsService.trackEvent('session_end', sessionData);

    // ë¡œì»¬ì— ë°±ì—… ì €ì¥ (ì˜¤í”„ë¼ì¸ ëŒ€ì‘)
    await this.saveSessionDataLocally(sessionData);

    // ì„¸ì…˜ ë°ì´í„° ì´ˆê¸°í™”
    this.sessionStart = null;
    this.sessionId = null;
    this.interactions = [];
  }

  async trackInteraction(type, target, context = {}) {
    const interaction = {
      type,
      target,
      timestamp: Date.now(),
      context
    };

    this.interactions.push(interaction);

    // ì‹¤ì‹œê°„ ìƒí˜¸ì‘ìš© ì¶”ì 
    await analyticsService.trackEvent('user_interaction', {
      interaction_type: type,
      interaction_target: target,
      session_id: this.sessionId,
      ...context
    });

    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì—ë„ ì „ì†¡
    await performanceMonitoring.trackUserAction(`interaction_${type}`, {
      target,
      ...context
    });
  }

  async saveSessionDataLocally(sessionData) {
    try {
      const existingSessions = await AsyncStorage.getItem('pending_sessions');
      const sessions = existingSessions ? JSON.parse(existingSessions) : [];
      
      sessions.push(sessionData);
      
      // ìµœëŒ€ 10ê°œ ì„¸ì…˜ë§Œ ë³´ê´€
      if (sessions.length > 10) {
        sessions.shift();
      }
      
      await AsyncStorage.setItem('pending_sessions', JSON.stringify(sessions));
    } catch (error) {
      console.error('Failed to save session data locally:', error);
    }
  }

  async sendPendingSessionData() {
    try {
      const pendingSessions = await AsyncStorage.getItem('pending_sessions');
      if (!pendingSessions) return;

      const sessions = JSON.parse(pendingSessions);
      
      for (const sessionData of sessions) {
        await analyticsService.trackEvent('session_data_delayed', sessionData);
      }

      // ì „ì†¡ ì™„ë£Œ í›„ ë¡œì»¬ ë°ì´í„° ì‚­ì œ
      await AsyncStorage.removeItem('pending_sessions');
    } catch (error) {
      console.error('Failed to send pending session data:', error);
    }
  }
}

export const sessionTracking = new SessionTrackingService();
```

## ë³´ì•ˆ ëª¨ë‹ˆí„°ë§

### ë³´ì•ˆ ì´ë²¤íŠ¸ ì¶”ì 

#### ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
```javascript
// src/services/securityMonitoring.js
import { createLogger } from '../utils/logger';
import { alertService } from './alertService';
import { cloudwatchMetrics } from '../utils/cloudwatch';

const logger = createLogger('security');

class SecurityMonitoringService {
  constructor() {
    this.suspiciousActivity = new Map();
    this.rateLimits = new Map();
  }

  // ë¡œê·¸ì¸ ì‹œë„ ëª¨ë‹ˆí„°ë§
  async trackLoginAttempt(userId, ip, success, context = {}) {
    const logData = {
      userId,
      ip,
      success,
      timestamp: Date.now(),
      userAgent: context.userAgent,
      location: context.location
    };

    if (success) {
      logger.info('Successful login', logData);
      
      // ì„±ê³µ ë¡œê·¸ì¸ ë©”íŠ¸ë¦­
      cloudwatchMetrics.putMetric('SuccessfulLogins', 1, 'Count');
      
      // ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ì´ˆê¸°í™”
      this.suspiciousActivity.delete(`login_${userId}`);
    } else {
      logger.warn('Failed login attempt', logData);
      
      // ì‹¤íŒ¨ ë¡œê·¸ì¸ ë©”íŠ¸ë¦­
      cloudwatchMetrics.putMetric('FailedLogins', 1, 'Count');
      
      // ì—°ì† ì‹¤íŒ¨ ì¶”ì 
      await this.trackFailedAttempts(userId, ip);
    }
  }

  // ì—°ì† ì‹¤íŒ¨ ë¡œê·¸ì¸ ì¶”ì 
  async trackFailedAttempts(userId, ip) {
    const key = `login_${userId}`;
    const ipKey = `ip_${ip}`;
    
    // ì‚¬ìš©ìë³„ ì‹¤íŒ¨ ì¹´ìš´íŠ¸
    const userFailures = this.suspiciousActivity.get(key) || 0;
    this.suspiciousActivity.set(key, userFailures + 1);
    
    // IPë³„ ì‹¤íŒ¨ ì¹´ìš´íŠ¸
    const ipFailures = this.suspiciousActivity.get(ipKey) || 0;
    this.suspiciousActivity.set(ipKey, ipFailures + 1);
    
    // ì„ê³„ê°’ í™•ì¸
    if (userFailures >= 5) {
      await this.reportSuspiciousActivity('multiple_failed_logins_user', {
        userId,
        attempts: userFailures + 1
      });
    }
    
    if (ipFailures >= 10) {
      await this.reportSuspiciousActivity('multiple_failed_logins_ip', {
        ip,
        attempts: ipFailures + 1
      });
    }
  }

  // Band API ë³´ì•ˆ ëª¨ë‹ˆí„°ë§
  async trackBandAPIAccess(userId, endpoint, success, context = {}) {
    const logData = {
      userId,
      endpoint,
      success,
      timestamp: Date.now(),
      ...context
    };

    if (success) {
      logger.info('Band API access', logData);
    } else {
      logger.warn('Band API access failed', logData);
      
      // Band API ì‹¤íŒ¨ ì¶”ì 
      const key = `band_api_${userId}`;
      const failures = this.suspiciousActivity.get(key) || 0;
      this.suspiciousActivity.set(key, failures + 1);
      
      if (failures >= 3) {
        await this.reportSuspiciousActivity('band_api_repeated_failures', {
          userId,
          endpoint,
          attempts: failures + 1
        });
      }
    }
  }

  // Rate Limiting ëª¨ë‹ˆí„°ë§
  async trackRateLimit(userId, endpoint, exceeded = false) {
    const key = `rate_limit_${userId}_${endpoint}`;
    
    if (exceeded) {
      logger.warn('Rate limit exceeded', { userId, endpoint });
      
      const violations = this.rateLimits.get(key) || 0;
      this.rateLimits.set(key, violations + 1);
      
      cloudwatchMetrics.putMetric('RateLimitViolations', 1, 'Count', [
        { Name: 'Endpoint', Value: endpoint }
      ]);
      
      if (violations >= 5) {
        await this.reportSuspiciousActivity('excessive_rate_limit_violations', {
          userId,
          endpoint,
          violations: violations + 1
        });
      }
    }
  }

  // ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ë³´ê³ 
  async reportSuspiciousActivity(activityType, details) {
    logger.error('Suspicious activity detected', {
      activityType,
      details
    });

    // CloudWatch ë©”íŠ¸ë¦­
    cloudwatchMetrics.putMetric('SuspiciousActivity', 1, 'Count', [
      { Name: 'ActivityType', Value: activityType }
    ]);

    // ì¦‰ì‹œ ì•Œë¦¼
    await alertService.sendErrorAlert(
      new Error(`Suspicious activity: ${activityType}`),
      details
    );

    // ì¶”ê°€ ë³´ì•ˆ ì¡°ì¹˜ê°€ í•„ìš”í•œ ê²½ìš°
    if (this.requiresImmediateAction(activityType)) {
      await this.triggerSecurityResponse(activityType, details);
    }
  }

  // ì¦‰ì‹œ ëŒ€ì‘ì´ í•„ìš”í•œ í™œë™ í™•ì¸
  requiresImmediateAction(activityType) {
    const criticalActivities = [
      'multiple_failed_logins_ip',
      'excessive_rate_limit_violations',
      'potential_account_takeover'
    ];
    
    return criticalActivities.includes(activityType);
  }

  // ìë™ ë³´ì•ˆ ëŒ€ì‘
  async triggerSecurityResponse(activityType, details) {
    logger.error('Triggering automatic security response', {
      activityType,
      details
    });

    // êµ¬ì²´ì ì¸ ë³´ì•ˆ ëŒ€ì‘ ë¡œì§ êµ¬í˜„
    // ì˜ˆ: IP ì°¨ë‹¨, ê³„ì • ì„ì‹œ ì ê¸ˆ, ì¶”ê°€ ì¸ì¦ ìš”êµ¬ ë“±
  }

  // ì •ê¸°ì  ì •ë¦¬ ì‘ì—…
  cleanupOldData() {
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    
    // 1ì‹œê°„ ì´ìƒ ëœ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ë°ì´í„° ì •ë¦¬
    for (const [key, timestamp] of this.suspiciousActivity.entries()) {
      if (timestamp < oneHourAgo) {
        this.suspiciousActivity.delete(key);
      }
    }
    
    // Rate limit ë°ì´í„°ë„ ì •ë¦¬
    for (const [key, timestamp] of this.rateLimits.entries()) {
      if (timestamp < oneHourAgo) {
        this.rateLimits.delete(key);
      }
    }
  }
}

export const securityMonitoring = new SecurityMonitoringService();

// 1ì‹œê°„ë§ˆë‹¤ ì •ë¦¬ ì‘ì—… ì‹¤í–‰
setInterval(() => {
  securityMonitoring.cleanupOldData();
}, 60 * 60 * 1000);
```

## ëŒ€ì‹œë³´ë“œ ë° ì‹œê°í™”

### Grafana ëŒ€ì‹œë³´ë“œ ì„¤ì •

#### ëŒ€ì‹œë³´ë“œ JSON ì„¤ì •
```json
{
  "dashboard": {
    "title": "DongBaeJul Monitoring Dashboard",
    "tags": ["dongbaejul", "monitoring"],
    "timezone": "Asia/Seoul",
    "panels": [
      {
        "id": 1,
        "title": "API Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.50, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))",
            "legendFormat": "50th percentile"
          }
        ],
        "yAxes": [
          {
            "label": "seconds",
            "min": 0
          }
        ]
      },
      {
        "id": 2,
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total[5m]))",
            "legendFormat": "Total RPS"
          },
          {
            "expr": "sum(rate(http_requests_total{status_code=~\"5..\"}[5m]))",
            "legendFormat": "Error RPS"
          }
        ]
      },
      {
        "id": 3,
        "title": "Active Games",
        "type": "singlestat",
        "targets": [
          {
            "expr": "games_active_total",
            "legendFormat": "Active Games"
          }
        ]
      },
      {
        "id": 4,
        "title": "Daily Active Users",
        "type": "singlestat",
        "targets": [
          {
            "expr": "daily_active_users",
            "legendFormat": "DAU"
          }
        ]
      },
      {
        "id": 5,
        "title": "Band API Health",
        "type": "table",
        "targets": [
          {
            "expr": "band_api_calls_total",
            "format": "table",
            "legendFormat": "Band API Calls"
          }
        ]
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
```

ì´ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ì‹œìŠ¤í…œì„ í†µí•´ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ íŒŒì•…í•˜ê³  ë¬¸ì œë¥¼ ì‹ ì†í•˜ê²Œ ëŒ€ì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.